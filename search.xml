<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cache-patterns</title>
    <url>/posts/7746b112/</url>
    <content><![CDATA[<p>缓存使用得当，可以降低应用的响应时间，减少数据库压力同时节约资源成本。</p>
<p>考虑缓存使用方式前应该思考的问题：</p>
<ul>
<li>系统是读多写少？</li>
<li>系统是写多读少？</li>
<li>数据变化频率高吗？</li>
</ul>
<p>两大类：</p>
<ul>
<li>cache-aside：数据快照</li>
<li>cache-as-sor：缓存即为数据源</li>
</ul>
<h2 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h2><p><img src="/images/cacheAside.png" alt="cache-aside"></p>
<ul>
<li>cashe-aside模式适用于读多的工作场景。</li>
<li>使用caceh-aside模式的系统对缓存命中失败有一定的容错率。</li>
<li>通过应用来访问缓存和数据库可以解耦数据库和缓存，不需要缓存和数据库的结构保持一致。</li>
<li>通过TTL时间来保证cache和database的数据一致性。如果数据一致性需要强一致的话，需要主动失效缓存或者使用其他策略。</li>
</ul>
<h2 id="Read-Through-Cache"><a href="#Read-Through-Cache" class="headerlink" title="Read-Through Cache"></a>Read-Through Cache</h2><p><img src="/images/readThrough.png" alt="read-through"></p>
<ul>
<li>cache-aside通过application来访问缓存和数据库。read-through通过cache provide来访问数据库。</li>
<li>read-through的数据结构需要和数据库保持一致</li>
<li>参考guava cache的cacheLoader实现</li>
</ul>
<h2 id="Write-Through-Cache"><a href="#Write-Through-Cache" class="headerlink" title="Write-Through Cache"></a>Write-Through Cache</h2><p><img src="/images/writeThrough.png" alt="write-through"></p>
<ul>
<li>write-through模式引入了额外的写入性能问题，因为需要先写入cahce，再写回数据库。</li>
<li>配合read-through一起使用可以完美发挥这种模式的优势，高效的查询和数据的最终一致性。</li>
<li>DynamoDB Accelerator（DAX）一个read-through/write-through缓存的典型例子。</li>
</ul>
<h2 id="write-aroud"><a href="#write-aroud" class="headerlink" title="write-aroud"></a>write-aroud</h2><p>先写数据库，数据只有在需要使用的时候才会被加载进缓存，通常配合cache-aside和read-through使用。</p>
<h2 id="write-back（write-behind）"><a href="#write-back（write-behind）" class="headerlink" title="write-back（write-behind）"></a>write-back（write-behind）</h2><p><img src="/images/writeBack.png" alt="write-back"></p>
<ul>
<li>先写缓存，最终同步到数据库。适用于写多的场景，例如系统高峰期的写操作。</li>
<li>配合cache-aside可以大幅提高峰值读写问题。</li>
<li>如果缓存写失败可能或者同步失败可能存在数据丢失问题。</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>cache-aside + write-around：适用于大多数缓存使用场景，对缓存未命中存在一定的容错性。</li>
<li>read-through + write-through/write-back：适用于高性能并发读写场景，如秒杀等。</li>
</ul>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>cache-patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁调研</title>
    <url>/posts/c1b07405/</url>
    <content><![CDATA[<h3 id="使用分布式锁的目的-意义："><a href="#使用分布式锁的目的-意义：" class="headerlink" title="使用分布式锁的目的/意义："></a>使用分布式锁的目的/意义：</h3><p>1、efficiency：为了提高效率，节约资源，避免重复操作。</p>
<p>2、correctness：为了数据的一致性，保证业务正确。</p>
<h3 id="redis分布式锁（single-instance）"><a href="#redis分布式锁（single-instance）" class="headerlink" title="redis分布式锁（single instance）"></a>redis分布式锁（single instance）</h3><p><strong>基本特征</strong></p>
<ul>
<li>独占互斥</li>
<li>无死锁</li>
<li>有一定容错性</li>
</ul>
<p><strong>推荐用法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过set nx达到原子操作</span><br><span class="line">&#x2F;&#x2F; 设置30000毫秒为锁的生命周期，防止客户端崩溃导致锁一直被占用</span><br><span class="line">&#x2F;&#x2F; my_random_value作为锁的版本号，防止解锁的时候串锁</span><br><span class="line">&#x2F;&#x2F; 通过单机达到最高效率，单机备份做容错。适用于efficiency场景的分布式锁</span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<h3 id="redlock"><a href="#redlock" class="headerlink" title="redlock"></a>redlock</h3><p><strong>定义</strong></p>
<ul>
<li>在n个redis节点上同时上锁，只有在N/2 +1（至少3个）个节点同时加锁成功</li>
<li>且加锁时间小于锁的有效期，则认为上锁成功</li>
<li>上锁失败则所有节点解锁</li>
</ul>
<p><strong>失败重试</strong></p>
<ul>
<li>在获取锁失败后应该在随机时间后重新获取锁，减少并发竞争</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>锁的自动释放（因为key失效了）：最终锁可以再次被使用.</li>
<li>客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端会主动（提前）释放锁，而不是等到锁失效另外的客户端才能取到锁。.</li>
<li>当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取锁使用的时间，以最大限度地避免脑裂。</li>
</ul>
<p><strong>Martin提出的RedLock存在的问题</strong></p>
<p>问：redis分布式锁无法避免当客户端处理锁对应的逻辑超过来锁过期时间后，锁被其他客户端占有导致的资源冲突问题。（这个问题大多数分布式锁实现都无法避免，也比较难解决）。Martin提出应该提供fencing（栅栏）机制</p>
<p>答：</p>
<p>首先分布式锁需要自动失效，否则会有死锁问题。</p>
<p>redis中的random value可以起到token的作用。</p>
<p>且如果有fencing机制来保证race condition的话，分布式锁存在的意义是什么？</p>
<p>并没有正面回答这个问题，可能确实比较难解决。</p>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p><strong>实现方式一</strong></p>
<ul>
<li>客户端尝试创建一个znode节点，比如<code>/lock</code>。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</li>
<li>持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</li>
<li>znode应该被创建成ephemeral的。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</li>
</ul>
<p><strong>实现方式二</strong></p>
<ul>
<li>创建一个临时顺序节点，通过临时顺序节点的序号来判断是否获取锁成功</li>
<li>获取锁失败则监听上一个临时顺序节点（可以避免herd effect）</li>
<li>解锁后通过watcher机制通知下一个节点获取锁成功</li>
</ul>
<p><strong>对比redlock</strong></p>
<ul>
<li>没有redlock的过期时间问题，能在需要的时候让锁自动释放。但是可能会由于session过期的问题，导致锁被其他客户端占有产生冲突。</li>
<li>在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。</li>
<li>基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。</li>
</ul>
<h3 id="chubby"><a href="#chubby" class="headerlink" title="chubby"></a>chubby</h3><p><strong>特性</strong></p>
<ul>
<li><strong>advisory lock</strong></li>
<li><strong>coarse-grained（粗粒度的）</strong></li>
<li><strong>paxos algo</strong></li>
<li><strong>file system</strong></li>
</ul>
<p><strong>对比zookeeper、redlock</strong></p>
<ul>
<li>使用paxos协议保证一致性，只有一个master节点可以读写</li>
<li>封装了lock api，使用起来更方便</li>
<li>线性一致性</li>
</ul>
<p><strong>chubby解决延迟造成锁失效的机制</strong></p>
<ul>
<li>sequencer，类似于fencing token机制，锁的持有者可以随时请求一个sequencer，这是一个字节串，它由三部分组成：<ul>
<li>锁的名字。</li>
<li>锁的获取模式（排他锁还是共享锁）。</li>
<li>lock generation number（一个64bit的单调递增数字）。作用相当于fencing token或epoch number。</li>
</ul>
</li>
</ul>
<p>客户端拿到sequencer之后，在操作资源的时候把它传给资源服务器。然后，资源服务器负责对sequencer的有效性进行检查。检查可以有两种方式：</p>
<p>​        1、调用Chubby提供的API，CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效。</p>
<p>​        2、将客户端传来的sequencer与资源服务器当前观察到的最新的sequencer进行对比检查。可以理解为与Martin描述的对于fencing token的检查类似。</p>
<ul>
<li>lock-delay<ul>
<li>Chubby允许客户端为持有的锁指定一个lock-delay的时间值（默认是1分钟）。当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空(draining the queue)，尽量防止出现延迟到达的未处理请求。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统设计</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>亲缘性线程池</title>
    <url>/posts/c63a112e/</url>
    <content><![CDATA[<h4 id="亲缘性线程池"><a href="#亲缘性线程池" class="headerlink" title="亲缘性线程池"></a>亲缘性线程池</h4><ul>
<li>亲缘性线程池指顺序投递多个任务后，能保证具有相同属性的任务顺序执行。</li>
</ul>
<p>JDK默认线程池是不具有亲缘性的</p>
<ul>
<li><p>开源实现： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FPhantomThief%2Fsimple-pool" target="_blank" rel="noopener">https://github.com/PhantomThief/simple-pool</a></p>
</li>
<li><ul>
<li>实现原理</li>
<li>KeyAffinityExecutor - 通过维护一个<Key-ListeningExecutor>的映射，将相同属性的任务放进同一个队列中，使用单个线程执行单个队列中的任务，达到亲缘性的目的。</li>
</ul>
</li>
<li><p>存在问题思考</p>
</li>
<li><ul>
<li>通过key散列后，只有单线程处理任务，如何应对大量的同属性任务问题</li>
</ul>
</li>
<li><p>使用demo</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> KeyAffinityExecutor executor = KeyAffinityExecutor.newSerializingExecutor(<span class="number">50</span>,<span class="number">5</span>,<span class="string">"my-pool"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">1</span>).data(<span class="string">"1s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">2</span>).data(<span class="string">"2s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">1</span>).data(<span class="string">"11s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">3</span>).data(<span class="string">"3s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">1</span>).data(<span class="string">"111s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">2</span>).data(<span class="string">"22s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">3</span>).data(<span class="string">"33s"</span>).build());</span><br><span class="line">        personList.add(Person.builder().id(<span class="number">1</span>).data(<span class="string">"1111s"</span>).build());</span><br><span class="line">      </span><br><span class="line">        exceteBatch(personList);</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceteBatch</span><span class="params">(List&lt;Person&gt; personList)</span></span>&#123;</span><br><span class="line">        personList.forEach(p -&gt; executor.executeEx(p.getId(), () -&gt; &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        Integer id;</span><br><span class="line"></span><br><span class="line">        String data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id,String data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> PersonBuilder <span class="title">builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PersonBuilder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", data='"</span> + data + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">        Integer id;</span><br><span class="line"></span><br><span class="line">        String data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">id</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">data</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(id,data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-dbunit使用指南</title>
    <url>/posts/f363124e/</url>
    <content><![CDATA[<h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><p>​    帮助你些一个可以多次重复运行且不依赖数据库现在数据的单元测试。<br>​    官方文档：<a href="https://springtestdbunit.github.io/spring-test-dbunit/index.html" target="_blank" rel="noopener">传送门</a></p>
<h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><h4 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>​    具体版本视自己项目情况定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.springtestdbunit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test-dbunit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dbunit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dbunit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h4><h5 id="代码配置：基于现有可运行的单元测试的基础上，增加-TestExecutionListeners配置，如代码所示："><a href="#代码配置：基于现有可运行的单元测试的基础上，增加-TestExecutionListeners配置，如代码所示：" class="headerlink" title="代码配置：基于现有可运行的单元测试的基础上，增加@TestExecutionListeners配置，如代码所示："></a>代码配置：基于现有可运行的单元测试的基础上，增加@TestExecutionListeners配置，如代码所示：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="meta">@DbUnitConfiguration</span>(databaseConnection=&#123;<span class="string">"customDataSource"</span>)</span><br><span class="line"><span class="meta">@TestExecutionListeners</span>(&#123;DependencyInjectionTestExecutionListener<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">DbUnitTestExecutionListener</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DependencyInjectionTestExecutionListener</strong>：负责注入单元测试中使用到的依赖。</li>
<li><strong>DbUnitTestExecutionListener</strong>：负责处理dbunit相关注解（见3、主要功能说明）。</li>
<li><strong>DbUnitConfiguration</strong>:  检查自己的dataSource的beanName，如果属于{“dbUnitDatabaseConnection”, “dataSource”}其中之一，可省略这个配置，否则需要加上，配置自己的beanName。</li>
</ul>
<p><strong>注：{“dbUnitDatabaseConnection”, “dataSource”}为dbunit默认去springContext中加载dataSource时使用的beanName。</strong></p>
<h4 id="3、主要功能说明"><a href="#3、主要功能说明" class="headerlink" title="3、主要功能说明"></a>3、主要功能说明</h4><ul>
<li><strong>@DatabaseSetup</strong> - 在testMethod执行之前会执行@DatabaseSetup，用于初始化测试数据<ul>
<li>connection - 连接的数据源，单数据源可不配置</li>
<li>type - 操作类型，参考DatabaseOperation枚举</li>
<li>value - 数据xml</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DatabaseSetup的DatabaseOperation默认值是CLEAN_INSERT，即清空表再插入数据，</span></span><br><span class="line"><span class="comment">//  明显与我们需求不符，配置成DatabaseOperation.INSERT即可。</span></span><br><span class="line"><span class="meta">@DatabaseSetup</span>(value =  <span class="string">"classpath:biz_info.xml"</span>,type = DatabaseOperation.INSERT)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@DatabaseTearDown</strong> -  在testMethod执行之后会执行@DatabaseTearDown，用于回滚删除测试数据<br>配置项与@DatabaseSetup一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DatabaseTearDown的DatabaseOperation默认值为CLEAN_INSERT，即删除插入的数据。</span></span><br><span class="line"><span class="meta">@DatabaseTearDown</span>(<span class="string">"classpath:biz_info.xml"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ExpectedDatabase</strong> -  在testMethod执行之后会执行@ExpectedDatabase，早于@DatabaseTearDown用于测试结果校验（<em>比较的是数据库中当前的记录和xml中配置的数据值是否完全一致，有点鸡肋</em>）<ul>
<li>connection - 连接的数据源，单数据源可不配置</li>
<li>value - 数据xml</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较的是数据库的值和xml中配置的数据值，有点鸡肋</span></span><br><span class="line"><span class="meta">@ExpectedDatabase</span>(<span class="string">"classpath:result.xml"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h4><ul>
<li><p>如何配置回滚</p>
<ol>
<li>修改<strong><em>DbUnitTestExecutionListener</em></strong>为<strong><em>TransactionDbUnitTestExecutionListener。</em></strong></li>
<li>加上<strong><em>@Transactional</em></strong>注解。</li>
<li>在method上配置<strong>@DatabaseTearDown，</strong>标明要回滚删除哪些数据。</li>
</ol>
</li>
<li><p>多数据源如何配置</p>
<ol>
<li>测试类上配置@DbUnitConfiguration(databaseConnection={“customDataSource”,”dataSource”})</li>
<li>在method上使用@DatabaseTearDown|@DatabaseSetUp|@ExpectedDatabase时加上connection配置,指定dataSource</li>
</ol>
</li>
</ul>
<p><strong>例：@DatabaseTearDown(connection = “dataSource”,value=”classpath:biz_info.xml”)**</strong></p>
<hr>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:daoApplicationContext.xml"</span>)</span><br><span class="line"><span class="meta">@DbUnitConfiguration</span>(databaseConnection = &#123;<span class="string">"dateSource"</span>&#125;)</span><br><span class="line"><span class="meta">@TestExecutionListeners</span>(&#123;DependencyInjectionTestExecutionListener<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">TransactionDbUnitTestExecutionListener</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Transactional</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DistributeConfigTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BizInfoDAO bizInfoDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DatabaseSetup</span>(value =  <span class="string">"classpath:biz_info.xml"</span>,type = DatabaseOperation.INSERT)</span><br><span class="line">    <span class="meta">@DatabaseTearDown</span>(connection = <span class="string">"dateSource"</span>,value = <span class="string">"classpath:biz_info.xml"</span>)</span><br><span class="line">    <span class="meta">@ExpectedDatabase</span>(connection = <span class="string">"dateSource"</span>,value = <span class="string">"classpath:result.xml"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_findAllBizInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;BizInfoPO&gt; bizInfoList = bizInfoDAO.findAll();</span><br><span class="line"></span><br><span class="line">        assertNotNull(bizInfoList);</span><br><span class="line">        assertEquals(<span class="number">2</span>,bizInfoList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>biz_info.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- biz_info为表名，后面是字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">biz_info</span>  <span class="attr">delete_mark</span>=<span class="string">"0"</span> <span class="attr">biz_code</span>=<span class="string">"a"</span> <span class="attr">biz_name</span>=<span class="string">"a"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">biz_info</span>  <span class="attr">delete_mark</span>=<span class="string">"0"</span> <span class="attr">biz_code</span>=<span class="string">"b"</span> <span class="attr">biz_name</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>result.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">biz_info</span>  <span class="attr">delete_mark</span>=<span class="string">"0"</span> <span class="attr">biz_code</span>=<span class="string">"a"</span> <span class="attr">biz_name</span>=<span class="string">"a"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">biz_info</span>  <span class="attr">delete_mark</span>=<span class="string">"0"</span> <span class="attr">biz_code</span>=<span class="string">"b"</span> <span class="attr">biz_name</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>unit-test</category>
      </categories>
      <tags>
        <tag>dbUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>Caffeine</title>
    <url>/posts/aa7617fc/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>Caffeine是一个基于Java8和Guava Cache重写的高性能的JVM缓存工具。</p>
<h4 id="官方文档地址：https-github-com-ben-manes-caffeine"><a href="#官方文档地址：https-github-com-ben-manes-caffeine" class="headerlink" title="官方文档地址：https://github.com/ben-manes/caffeine"></a>官方文档地址：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></h4><h4 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h4><p>Caffeine使用了W-TinyLFU淘汰算法，使缓存命中率提升至接近最佳，同时占用的内存尽可能少。</p>
<h4 id="不同类型的实现："><a href="#不同类型的实现：" class="headerlink" title="不同类型的实现："></a>不同类型的实现：</h4><ul>
<li>Cache - 手动填充缓存：<ul>
<li>需要显式的去控制缓存的创建，更新和删除。</li>
</ul>
</li>
<li>LoadingCache - 同步加载缓存：<ul>
<li>使用CacheLoader来构建的缓存的值。批量查找可以使用<code>Caffeine.getAll(Iterable&lt;? extends String&gt;)</code>方法。默认情况下，getAll将会对缓存中没有值的key分别调用<code>CacheLoader.load</code>方法来构建缓存的值。我们可以重写<code>CacheLoader.loadAll</code>方法来提高getAll的效率。</li>
<li>如果get一个不存在的key，会调用定义好的load方法，加载一个默认值。可有效应对恶意调用不存在的key的攻击行为，防止缓存击穿。</li>
</ul>
</li>
<li>AsyncLoadingCache - 异步加载缓存：</li>
<li>AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture。异步加载缓存使用了响应式编程模型。</li>
</ul>
<h4 id="过期策略："><a href="#过期策略：" class="headerlink" title="过期策略："></a>过期策略：</h4><ul>
<li><p>size - 基于容量/大小</p>
<ul>
<li><code>Caffeine.maximumSize(long)</code>，例 long = 1000 表示最有同时存储1000个Entry，也就是缓存1000个K-V值。`</li>
<li><code>Caffeine.estimatedSize()</code>返回当前已经占用的Entry数。基于权重(比较难理解，我也还没理解)</li>
<li><code>Caffeine.maximumWeight(long)</code>。CacheBuilder.weigher(Weigher)，可以指定权重函数。通过权重函数计算出当前对‘总重’。如果‘总重’超过限制，就淘汰缓存。</li>
</ul>
</li>
<li><p>time - 基于时间</p>
<ul>
<li><p><code>Caffeine.expireAfterAccess(long, TimeUnit)</code> 缓存项在给定时间内没有被‘读/写’访问，则回收。</p>
</li>
<li><p><code>Caffeine.expireAfterWrite(long, TimeUnit)</code>  缓存项在给定时间内没有被写访问（创建或覆盖），则回收。</p>
</li>
<li><p><code>Caffeine.expireAfter(Expiry)</code> 可以在Expiry中分别自定义 读／写／创建等操作的超时时间，比上面两种策略更加灵活。</p>
</li>
</ul>
</li>
<li><p>reference - 基于引用</p>
<ul>
<li><p><code>Caffeine.weakKeys()</code>使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用键的缓存用==而不是equals比较键。</p>
</li>
<li><p><code>Caffeine.weakValues()</code>使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用值的缓存用==而不是equals比较值。</p>
</li>
<li><p><code>Caffeine.softValues()</code>使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，建议使用更有性能预测性的缓存大小限定。使用软引用值的缓存同样用==而不是equals比较值。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Java4种引用的级别由高到低依次为：强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</strong></p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用</td>
<td>在内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用</td>
<td>在垃圾回收时</td>
<td>对象缓存</td>
<td>gc运行后终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><ul>
<li>一些术语<ul>
<li>eviction - 驱逐，因为过期策略而删除</li>
<li>invalidation - 失效，由用户手动触发而删除</li>
<li>removal - 移除结果，发生eviction或者invalidation产生的通知结果</li>
</ul>
</li>
<li>​    任何时候，你都可以显式地清除缓存项：<ul>
<li>单个清除：<code>Cache.invalidate(key)</code></li>
<li>批量清除：<code>Cache.invalidateAll(keys)</code></li>
<li>清除所有缓存项：<code>Cache.invalidateAll()</code></li>
</ul>
</li>
<li>监听器<ul>
<li>通过<code>CacheBuilder.removalListener(RemovalListener)</code>，你可以声明一个监听器，以便缓存项被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知(RemovalNotification)，其中包含移除原因(RemovalCause)、键和值。</li>
<li>监听器的操作是异步的，由executor执行。executor默认实现是<code>ForkJoinPool.commonPool()</code>。也可以通过<code>Caffeine.executor(Executor)</code>设置想要的executor。</li>
</ul>
</li>
</ul>
<h4 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h4><ul>
<li>通过<code>Caffeine.recordStats()</code>可以开启数据统计。</li>
<li>调用<code>Cache.stats()</code>可以拿到CacheStats数据对象，包含：</li>
<li>hitRate() - 命中率<ul>
<li>evictionCount() - 移除的缓存数量</li>
<li>averageLoadPenalty() - 加载新缓存的平均时间</li>
<li>……等</li>
</ul>
</li>
<li>统计的数据也可以通过被动推送的方式拿到，这里不过多描述，有兴趣可以自己研究。</li>
</ul>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li>Tiker</li>
<li>自定义时钟，可以不使用系统默认的时钟，通过自定义的时钟控制缓存的存活时间。</li>
<li>refresh</li>
<li>LoadingCache的特性，刷新缓存，刷新与删除再写入的不同点在于：刷新为非阻塞操作，在并发的情况下，其他线程可以在刷新的过程中取到旧值。而eviction则会阻塞线程保证数据一致性。</li>
<li>AsMap</li>
<li>Caffeine可以转成ConcurrentMap进行操作。转换后的map和cache共享数据，所以更新操作会相互影响。</li>
<li>在Spring框架中使用Caffeine<ul>
<li>通过Spring的CaffeineCacheManager来管理Caffeine的生命周期。</li>
<li>详情见Spring官方文档：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration-caffeine" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration-caffeine</a></li>
</ul>
</li>
</ul>
<h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 手动操作型cache</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Cache&lt;String,Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                                    .maximumSize(<span class="number">2</span>) <span class="comment">// 最多两个Entry</span></span><br><span class="line">                                    .expireAfterWrite(Duration.ofSeconds(<span class="number">5</span>)) <span class="comment">// 5s不被使用自动过期</span></span><br><span class="line">                                    .recordStats() <span class="comment">// 开启调用统计</span></span><br><span class="line">                                    .build();</span><br><span class="line"></span><br><span class="line">      cache.put(<span class="string">"key1"</span>,<span class="string">"val1"</span>);</span><br><span class="line">      cache.put(<span class="string">"key2"</span>,<span class="string">"val2"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(cache.estimatedSize()); <span class="comment">// 2</span></span><br><span class="line">      cache.getIfPresent(<span class="string">"key1"</span>);</span><br><span class="line"></span><br><span class="line">      cache.put(<span class="string">"key3"</span>,<span class="string">"val3"</span>); <span class="comment">// 此时容量超过2，会淘汰使用频次较低的key2</span></span><br><span class="line">      System.out.println(cache.getIfPresent(<span class="string">"key3"</span>)); <span class="comment">// val3</span></span><br><span class="line">      System.out.println(cache.getIfPresent(<span class="string">"key1"</span>)); <span class="comment">// val1</span></span><br><span class="line">      System.out.println(cache.getIfPresent(<span class="string">"key2"</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      cache.invalidate(<span class="string">"key1"</span>);</span><br><span class="line">      System.out.println(cache.getIfPresent(<span class="string">"key1"</span>)); <span class="comment">// null</span></span><br><span class="line">      <span class="comment">//get操作可同时传入一个Callable，数据若不存在会调用Callable计算并存入缓存</span></span><br><span class="line">      System.out.println(cache.get(<span class="string">"key1"</span>,key -&gt; <span class="string">"val1"</span>)); <span class="comment">//val1</span></span><br><span class="line"></span><br><span class="line">      cache.invalidateAll();</span><br><span class="line">      System.out.println(cache.stats().hitRate()); <span class="comment">// 0.5 get6次 命中3次</span></span><br><span class="line">      System.out.println(cache.stats().evictionCount()); <span class="comment">// 1</span></span><br><span class="line">      System.out.println(cache.estimatedSize()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(<span class="string">"ClassName"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自动加载型cache</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LoadingCache&lt;String,Object&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">                                          .maximumSize(<span class="number">50</span>)</span><br><span class="line">                                          .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                                          .recordStats()</span><br><span class="line">                                          .removalListener((String key,Object obj, RemovalCause cause) -&gt; &#123;</span><br><span class="line">                                            logger.info(<span class="string">"key:&#123;&#125;,val:&#123;&#125;,cause:&#123;&#125;"</span>,key,obj,cause);</span><br><span class="line">                                            System.out.printf(<span class="string">"Key %s was removed (%s)%n"</span>, key, cause);</span><br><span class="line">                                          &#125;)</span><br><span class="line">                                          <span class="comment">// 注入load方法 </span></span><br><span class="line">                                          .build(key -&gt; <span class="string">"default"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 由于key不存在 生成了值为default的缓存</span></span><br><span class="line">   System.out.println(loadingCache.get(<span class="string">"keyNotExist"</span>));<span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   Map&lt;String,Object&gt; map = Maps.newHashMap();</span><br><span class="line">   map.put(<span class="string">"key1"</span>,<span class="string">"val1"</span>);</span><br><span class="line">   map.put(<span class="string">"key2"</span>,<span class="string">"val2"</span>);</span><br><span class="line">   map.put(<span class="string">"key3"</span>,<span class="string">"val3"</span>);</span><br><span class="line"></span><br><span class="line">   loadingCache.putAll(map);</span><br><span class="line">   System.out.println(loadingCache.get(<span class="string">"key1"</span>));<span class="comment">// val1</span></span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; keySet = Sets.newHashSet(<span class="string">"key5"</span>,<span class="string">"key6"</span>,<span class="string">"key7"</span>);</span><br><span class="line">   loadingCache.getAll(keySet);</span><br><span class="line">   System.out.println(loadingCache.get(<span class="string">"key5"</span>));<span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   ConcurrentMap&lt;String,Object&gt; map1 = loadingCache.asMap();</span><br><span class="line">   <span class="keyword">for</span> (Map.Entry entry : map1.entrySet()) &#123;</span><br><span class="line">       <span class="comment">// key1:val1|key2:val2|key5:default|key6:default|key3:val3|key7:default|keyNotExist:default</span></span><br><span class="line">       System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    map1.remove(<span class="string">"key2"</span>);</span><br><span class="line">    System.out.println(loadingCache.getIfPresent(<span class="string">"key2"</span>)); <span class="comment">// null 通过map操作也会影响loadingCache</span></span><br><span class="line"></span><br><span class="line">   loadingCache.invalidate(<span class="string">"key1"</span>);</span><br><span class="line">   System.out.println(loadingCache.estimatedSize()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>本地缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式-创建型</title>
    <url>/posts/21f4dc22/</url>
    <content><![CDATA[<h3 id="简单工厂（静态工厂）"><a href="#简单工厂（静态工厂）" class="headerlink" title="简单工厂（静态工厂）"></a>简单工厂（静态工厂）</h3><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</p>
<p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>基于简单工厂的抽象，解决简单工厂的if-else判断问题，使用抽象和多态将不同的创建方法分离到不同的类中。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>可以同时创建不同产品族的对象。</p>
<h4 id="工厂模式的作用"><a href="#工厂模式的作用" class="headerlink" title="工厂模式的作用"></a>工厂模式的作用</h4><ul>
<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>
<li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li>
<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>
<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>
</ul>
<h4 id="工厂模式与DI"><a href="#工厂模式与DI" class="headerlink" title="工厂模式与DI"></a>工厂模式与DI</h4><p>Dependency Injection是工厂模式的扩展，拥有比工厂模式更多的功能，如配置解析和对象生命周期管理。其核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p>
<p><strong>Ps：总结自王争老师极客时间设计模式课程，侵删。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式、桥接模式、装饰模式器、适配器模式对比总结</title>
    <url>/posts/9ec2c02f/</url>
    <content><![CDATA[<h3 id="什么是结构型模式"><a href="#什么是结构型模式" class="headerlink" title="什么是结构型模式"></a>什么是结构型模式</h3><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：<strong>代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式</strong>。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式旨在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p><strong>动态代理</strong></p>
<ul>
<li>jdk动态代理</li>
<li>cglib动态代理</li>
</ul>
<p><strong>代理模式的应用场景</strong></p>
<ul>
<li><strong>业务系统的非功能性需求开发</strong>：代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：<strong>监控、统计、鉴权、限流、事务、幂等、日志</strong>。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。</li>
<li><strong>代理模式在 RPC、缓存中的应用</strong>：实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>在 GoF 的《设计模式》一书中，桥接模式被定义为：“<strong>将抽象和实现解耦，让它们可以独立变化。</strong>”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p>
<p><strong>典型应用</strong></p>
<ul>
<li>jdbc驱动：jdbc的行为模式由DriverManager定义，实际和数据库的交互由Driver实现。从而达到相互解耦，独立扩展。</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<p><strong>特点</strong></p>
<ul>
<li>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</li>
<li>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</li>
</ul>
<p><strong>典型应用</strong></p>
<ul>
<li>JDK IO流</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ul>
<p><strong>典型应用</strong></p>
<ul>
<li>slf4j日志框架</li>
</ul>
<h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p>
<ul>
<li><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>
<li><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
<li><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
<li><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>
</ul>
<p><strong>Ps：总结自王争老师极客时间设计模式课程，侵删。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构性模式</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列设计精要</title>
    <url>/posts/10e7a6ee/</url>
    <content><![CDATA[<h4 id="消息队列设计精要"><a href="#消息队列设计精要" class="headerlink" title="消息队列设计精要"></a>消息队列设计精要</h4><p>文章引用：<a href="https://tech.meituan.com/2016/07/01/mq-design.html" target="_blank" rel="noopener">美团技术团队博客</a></p>
<p><strong>实现消息队列的基本功能</strong></p>
<ul>
<li><p>解决的核心问题</p>
<ul>
<li>解耦</li>
<li>最终一致性</li>
<li>广播</li>
<li>错峰与流控 - “通用漏斗”</li>
</ul>
</li>
<li><p>RPC通信协议 - 避免重复造轮子，使用现有RPC框架（thrift，dubbo等）</p>
</li>
<li><p>高可用</p>
</li>
<li><p>服务端承载消息对接的能力</p>
</li>
<li><p>存储子系统选择</p>
<p>理论上，从速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。还是要从支持的业务场景出发作出最合理的选择，如果你们的消息队列是用来支持支付/交易等对可靠性要求非常高，但对性能和量的要求没有这么高，而且没有时间精力专门做文件存储系统的研究，DB是最好的选择。 但是DB受制于IOPS，如果要求单broker 5位数以上的QPS性能，基于文件的存储是比较好的解决方案。整体上可以采用数据文件+索引文件的方式处理。 分布式KV（如MongoDB，HBase）等，或者持久化的Redis，由于其编程接口较友好，性能也比较可观，如果在可靠性要求不是那么高的场景，也不失为一个不错的选择。</p>
</li>
<li><p>消费关系解析</p>
</li>
<li><p>队列高级特性设计</p>
<ul>
<li><p>可靠投递（最终一致性）    </p>
<p>1、producer往broker发送消息之前，需要做一次落地。</p>
<p>2、请求到server后，server确保数据落地后再告诉客户端发送成功。</p>
<p>3、支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都OK才可删除消息。   </p>
</li>
<li><p>消费确认</p>
</li>
<li><p>重复消息和顺序消息</p>
<ul>
<li><p>如何鉴别消息重复，并幂等的处理重复消息</p>
</li>
<li><p>一个消息队列如何尽量减少重复消息的投递</p>
</li>
<li><p>版本号</p>
<ul>
<li>对发送方必须要求消息带业务版本号 </li>
<li>下游必须存储消息的版本号，对于要严格保证顺序的</li>
</ul>
</li>
<li><p>状态机</p>
</li>
<li><p>重复消息</p>
<ul>
<li>broker记录MessageId，直到投递成功后清除，重复的ID到来不做处理，这样只要发送者在清除周期内能够感知到消息投递成功，就基本不会在server端产生重复消息。</li>
<li>对于server投递到consumer的消息，由于不确定对端是在处理过程中还是消息发送丢失的情况下，有必要记录下投递的IP地址。决定重发之前询问这个IP，消息处理成功了吗？如果询问无果，再重发。</li>
</ul>
</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li>两阶段提交，分布式事务。<ul>
<li>分布式事务存在的最大问题是成本太高，两阶段提交协议，对于仲裁down机或者单点故障，几乎是一个无解的黑洞</li>
</ul>
</li>
<li>本地事务，本地落地，补偿发送<ul>
<li>配置较为复杂，“绑架”业务方，必须本地数据库实例提供一个库表。</li>
<li>对于消息延迟高敏感的业务不适用。</li>
</ul>
</li>
</ul>
</li>
<li><p>性能相关</p>
<ul>
<li>异步/同步<ul>
<li>服务端使用异步最大的好处：解放了线程和I/O（I/O合并和线程创建数量减少）</li>
</ul>
</li>
<li>批量<ul>
<li>减少无谓的请求头，如果你每个请求只有几字节，而头却有几十字节，无疑效率非常低下。</li>
<li>减少回复的ack包个数。把请求合并后，ack包数量必然减少，确认和重发的成本就会降低。</li>
</ul>
</li>
</ul>
</li>
<li><p>push/pull模式</p>
<ul>
<li>慢消费 - push模型致命伤，容易造成消息堆积。对于建立索引等慢消费，消息量有限且到来的速度不均匀的情况，pull模式比较合适</li>
<li>消息延迟与忙等<ul>
<li>解决方案<ul>
<li>从短时间开始指数级增长等待。开始等5ms，然后10ms，然后20ms知道消息到来回到5ms。但是并不能完全解决延迟问题。</li>
<li>rocketMq优化做法 - 长轮询，平衡推拉模型的各自缺点。消费者如果尝试拉取失败，不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来，把连接notify起来，这也是不错的思路。但海量的长连接block对系统的开销还是不容小觑的，还是要合理的评估时间间隔，给wait加一个时间上限比较好</li>
</ul>
</li>
</ul>
</li>
<li>顺序消息<ul>
<li>pull模式较push模式容易做到全局顺序消息，主要因为push模式满消费是瓶颈，且全局顺序容易出现慢消费和消息堆积。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统设计</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式-创建型</title>
    <url>/posts/545bbc59/</url>
    <content><![CDATA[<h4 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h4><ul>
<li>解决共享变量问题</li>
<li>资源重复创建的浪费资源问题</li>
<li>有些数据在系统中只应该保存一份，就比较适合设计为单例类</li>
</ul>
<h4 id="如何实现一个单例"><a href="#如何实现一个单例" class="headerlink" title="如何实现一个单例"></a>如何实现一个单例</h4><ul>
<li>构造函数private</li>
<li>创建对象时是否延迟加载</li>
<li>创建对象时是否线程安全</li>
<li>获取对象时性能是否高</li>
</ul>
<h4 id="单例的几种实现方式"><a href="#单例的几种实现方式" class="headerlink" title="单例的几种实现方式"></a>单例的几种实现方式</h4><ul>
<li><strong>饿汉式</strong>：饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</li>
<li><strong>懒汉式</strong>：懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</li>
<li><strong>双检锁</strong>：双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</li>
<li><strong>静态内部类</strong>：利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</li>
<li><strong>枚举</strong>：最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</li>
</ul>
<h4 id="单例存在的问题"><a href="#单例存在的问题" class="headerlink" title="单例存在的问题"></a>单例存在的问题</h4><ul>
<li>单例对OOP 特性的支持不友好</li>
<li>单例会隐藏类之间的依赖关系</li>
<li>单例对代码的扩展性不友好</li>
<li>单例对代码的可测试性不友好</li>
<li>单例不支持有参数的构造函数</li>
</ul>
<h4 id="单例的替代解决方案"><a href="#单例的替代解决方案" class="headerlink" title="单例的替代解决方案"></a>单例的替代解决方案</h4><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p>
<h4 id="集群下的单例模式"><a href="#集群下的单例模式" class="headerlink" title="集群下的单例模式"></a>集群下的单例模式</h4><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p>
<p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p><strong>Ps：总结自王争老师极客时间设计模式课程，侵删。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器模式-创建型</title>
    <url>/posts/5e6bf39b/</url>
    <content><![CDATA[<h4 id="为什么需要建造者模式"><a href="#为什么需要建造者模式" class="headerlink" title="为什么需要建造者模式"></a>为什么需要建造者模式</h4><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>
<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>
</ul>
<h4 id="工厂模式和建造者模式的区别"><a href="#工厂模式和建造者模式的区别" class="headerlink" title="工厂模式和建造者模式的区别"></a>工厂模式和建造者模式的区别</h4><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p><strong>Ps：总结自王争老师极客时间设计模式课程，侵删。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则总结</title>
    <url>/posts/a151c9f2/</url>
    <content><![CDATA[<h4 id="SRP-（Single-Responsibity-Principle）单一职责"><a href="#SRP-（Single-Responsibity-Principle）单一职责" class="headerlink" title="SRP （Single Responsibity Principle）单一职责"></a>SRP （Single Responsibity Principle）单一职责</h4><p>英文原文：<strong><em>A class or module should have a single reponsibility。</em></strong>一个类或者模块只负责完成一个职责（或者功能）。</p>
<ol>
<li><p><strong>如何理解单一职责原则（SRP）？</strong><br>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p>
</li>
<li><p><strong>如何判断类的职责是否足够单一？</strong><br>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。</p>
<p>一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
</li>
</ol>
<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li>类依赖的其他类过多，或者依赖类的其他类过多；</li>
<li>私有方法过多；比较难给类起一个合适的名字；</li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>
<ol start="3">
<li><p><strong>类的职责是否设计得越单一越好？</strong><br>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。</p>
<p>同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
</li>
</ol>
<h4 id="OCP（Open-Closed-Principle）开闭原则"><a href="#OCP（Open-Closed-Principle）开闭原则" class="headerlink" title="OCP（Open Closed Principle）开闭原则"></a>OCP（Open Closed Principle）开闭原则</h4><p>英文原文：<strong><em>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。</em></strong>我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<ol>
<li><p><strong>如何理解“对扩展开放、对修改关闭”？</strong><br>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<p>关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p>
</li>
<li><p><strong>如何做到“对扩展开放、修改关闭”？</strong><br>我们要时刻具备扩展意识、抽象意识、封装意识。</p>
<p>在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。</p>
<p>特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
</li>
</ol>
<h4 id="LSP（Liskov-Substitution-Principle）里氏替换原则"><a href="#LSP（Liskov-Substitution-Principle）里氏替换原则" class="headerlink" title="LSP（Liskov Substitution Principle）里氏替换原则"></a>LSP（Liskov Substitution Principle）里氏替换原则</h4><p>英文原文：<strong><em>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</em></strong>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p><strong><em>哪些代码明显违背了 LSP？</em></strong></p>
<ol>
<li><p><strong>子类违背父类声明要实现的功能</strong><br>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p>
</li>
<li><p><strong>子类违背父类对输入、输出、异常的约定</strong><br>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p>
<p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p>
<p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p>
</li>
<li><p><strong>子类违背父类注释中所罗列的任何特殊说明</strong><br>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p>
</li>
</ol>
<p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p>
<p><strong>总结：</strong></p>
<p>​        里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<p>​        理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p>
<h4 id="ISP（Interface-Segregation-Principle）接口隔离原则"><a href="#ISP（Interface-Segregation-Principle）接口隔离原则" class="headerlink" title="ISP（Interface Segregation Principle）接口隔离原则"></a>ISP（Interface Segregation Principle）接口隔离原则</h4><p>英文原文：“<strong><em>Clients should not be forced to depend upon interfaces that they do not use。</em></strong>”直译成中文的话就是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>
<ol>
<li><strong>如何理解“接口隔离原则”？</strong><br>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</li>
</ol>
<ul>
<li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li>
<li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li>
<li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</li>
</ul>
<ol start="2">
<li><p><strong>接口隔离原则与单一职责原则的区别单一职责原则针对的是模块、类、接口的设计。</strong><br>接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。</p>
<p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
</li>
</ol>
<h4 id="DIP（Dependency-Inversion-Principle）依赖反转"><a href="#DIP（Dependency-Inversion-Principle）依赖反转" class="headerlink" title="DIP（Dependency Inversion Principle）依赖反转"></a>DIP（Dependency Inversion Principle）依赖反转</h4><p>英文原文：<strong>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions</strong>.翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>
<ol>
<li><strong>控制反转</strong><br>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</li>
<li><strong>依赖注入</strong><br>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</li>
<li><strong>依赖注入框架</strong><br>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li>
<li><strong>依赖反转原则</strong><br>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</li>
</ol>
<h4 id="KISS（Keep-It-Simple-And-Stupid）尽量保持简单"><a href="#KISS（Keep-It-Simple-And-Stupid）尽量保持简单" class="headerlink" title="KISS（Keep It Simple And Stupid）尽量保持简单"></a>KISS（Keep It Simple And Stupid）尽量保持简单</h4><h4 id="YAGNI（You-Ain’t-Gonna-Need-It）不要过度设计"><a href="#YAGNI（You-Ain’t-Gonna-Need-It）不要过度设计" class="headerlink" title="YAGNI（You Ain’t Gonna Need It）不要过度设计"></a>YAGNI（You Ain’t Gonna Need It）不要过度设计</h4><p>KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。</p>
<p>而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。对于如何写出满足 KISS 原则的代码，我还总结了下面几条指导原则：</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码；</li>
<li>不要重复造轮子，要善于使用已经有的工具类库；</li>
<li>不要过度优化。</li>
</ul>
<h4 id="DRY（Dont-Repeat-Yourself）不重复原则"><a href="#DRY（Dont-Repeat-Yourself）不重复原则" class="headerlink" title="DRY（Dont Repeat Yourself）不重复原则"></a>DRY（Dont Repeat Yourself）不重复原则</h4><ol>
<li><strong>DRY 原则三种代码重复的情况：</strong><br>实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</li>
<li><strong>代码复用性今天，我们讲到提高代码可复用性的一些方法，有以下 7 点：</strong></li>
</ol>
<ul>
<li>减少代码耦合</li>
</ul>
<ul>
<li>满足单一职责原则</li>
<li>模块化业务与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h4 id="LOD（Low-Of-Demeter）迪米特法则-又叫（The-Least-Knowledge-Principle）最少知识原则"><a href="#LOD（Low-Of-Demeter）迪米特法则-又叫（The-Least-Knowledge-Principle）最少知识原则" class="headerlink" title="LOD（Low Of Demeter）迪米特法则 又叫（The Least Knowledge Principle）最少知识原则"></a>LOD（Low Of Demeter）迪米特法则 又叫（The Least Knowledge Principle）最少知识原则</h4><p>英文原文：<strong>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</strong>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>
<ol>
<li><p><strong>如何理解“高内聚、松耦合”？</strong><br>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。</p>
<p>“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p>
<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
</li>
<li><p><strong>如何理解“迪米特法则”？</strong><br>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
</li>
</ol>
<p><strong>Ps：总结自王争老师极客时间设计模式课程，侵删。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型-观察者模式</title>
    <url>/posts/c8efcbb/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>观察者模式</strong>（Observer Design Pattern）也被称为<strong>发布订阅模式</strong>（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：</p>
<p><strong><em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</em></strong></p>
<p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<h4 id="基于不同场景的不同实现方式"><a href="#基于不同场景的不同实现方式" class="headerlink" title="基于不同场景的不同实现方式"></a>基于不同场景的不同实现方式</h4><p>小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h4 id="对比生产者-消费者模式"><a href="#对比生产者-消费者模式" class="headerlink" title="对比生产者-消费者模式"></a>对比生产者-消费者模式</h4><ul>
<li>发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。</li>
<li>生产-消费模型，是多对多的关系，一般以异步的方式实现</li>
</ul>
<p>两者都可以达到解耦的作用</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li>jdk自带实现</li>
</ol>
<p>jdk自带的观察者模式实现比较简单，通过实现<strong>Observer</strong>接口实现观察者，<strong>Observable</strong>类作为观察机制的控制中心，负责观察者的生命周期管理及被观察者变化的通知。</p>
<p>核心类有两个：<strong>Observer</strong>接口和<strong>Observable</strong>类，简略代码如下（省略了部分非核心代码及注释）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心变量，标记被观察者是否发生了变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 核心变量，观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除观察者</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知变化</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123; </span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  状态变更watcher</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusWatcher</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"status change~~~~~~~~~~"</span>);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  状态变更observer</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusObserverImpl</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"notify~~~ arg:"</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、通过继承的方式实现观察者控制中心</span></span><br><span class="line"><span class="comment">// 2、实现Observer接口实现自己的观察者</span></span><br><span class="line"><span class="comment">// 3、调用setChanged()设置变更状态</span></span><br><span class="line"><span class="comment">// 4、调用notifyObservers(Obj)通知观察者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StatusWatcher watcher = <span class="keyword">new</span> StatusWatcher();</span><br><span class="line">    watcher.addObserver(<span class="keyword">new</span> StatusObserverImpl());</span><br><span class="line"></span><br><span class="line">    watcher.setStatus(<span class="string">"gggg"</span>);</span><br><span class="line">    watcher.setStatus(<span class="string">"oooo"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"~~~~~~end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>guava实现</li>
</ol>
<p>guava相对于jdk的实现来说功能更加丰富了一些，支持根据不同的入参唤醒不同的观察者，支持异步非阻塞的通知机制。</p>
<p>核心类：<strong>EventBus</strong>（事件总线）、<strong>Subscriber</strong>（观察者）、<strong>Dispatcher</strong>（事件分发器），核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(EventBus<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String identifier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubscriberExceptionHandler exceptionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubscriberRegistry subscribers = <span class="keyword">new</span> SubscriberRegistry(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">  EventBus(</span><br><span class="line">      String identifier,</span><br><span class="line">      Executor executor,</span><br><span class="line">      Dispatcher dispatcher,</span><br><span class="line">      SubscriberExceptionHandler exceptionHandler) &#123;</span><br><span class="line">    <span class="keyword">this</span>.identifier = checkNotNull(identifier);</span><br><span class="line">    <span class="keyword">this</span>.executor = checkNotNull(executor);</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = checkNotNull(dispatcher);</span><br><span class="line">    <span class="keyword">this</span>.exceptionHandler = checkNotNull(exceptionHandler);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    subscribers.register(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    subscribers.unregister(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);</span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers.hasNext()) &#123;</span><br><span class="line">      dispatcher.dispatch(event, eventSubscribers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line">      <span class="comment">// the event had no subscribers and was not itself a DeadEvent</span></span><br><span class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> Subscriber <span class="title">create</span><span class="params">(EventBus bus, Object listener, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isDeclaredThreadSafe(method)</span><br><span class="line">        ? <span class="keyword">new</span> Subscriber(bus, listener, method)</span><br><span class="line">        : <span class="keyword">new</span> SynchronizedSubscriber(bus, listener, method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The event bus this subscriber belongs to. */</span></span><br><span class="line">  <span class="meta">@Weak</span> <span class="keyword">private</span> EventBus bus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The object with the subscriber method. */</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Subscriber method. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Executor to use for dispatching events to this subscriber. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Subscriber</span><span class="params">(EventBus bus, Object target, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bus = bus;</span><br><span class="line">    <span class="keyword">this</span>.target = checkNotNull(target);</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.executor = bus.executor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Dispatches &#123;<span class="doctag">@code</span> event&#125; to this subscriber using the proper executor. */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(<span class="keyword">final</span> Object event)</span> </span>&#123;</span><br><span class="line">    executor.execute(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              invokeSubscriberMethod(event);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">              bus.handleSubscriberException(e.getCause(), context(event));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invokes the subscriber method. This method can be overridden to make the invocation</span></span><br><span class="line"><span class="comment">   * synchronized.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriberMethod</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method.invoke(target, checkNotNull(event));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Method rejected target/argument: "</span> + event, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Method became inaccessible: "</span> + event, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) e.getCause();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Dispatcher <span class="title">perThreadDispatchQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PerThreadQueuedDispatcher();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Dispatcher <span class="title">legacyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LegacyAsyncDispatcher();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Dispatcher <span class="title">immediate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmediateDispatcher.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerThreadQueuedDispatcher</span> <span class="keyword">extends</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Queue&lt;Event&gt;&gt; queue =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Queue&lt;Event&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> Queue&lt;Event&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Queues.newArrayDeque();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; dispatching =</span><br><span class="line">       <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> Boolean <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> </span>&#123;</span><br><span class="line">      checkNotNull(event);</span><br><span class="line">      checkNotNull(subscribers);</span><br><span class="line">      Queue&lt;Event&gt; queueForThread = queue.get();</span><br><span class="line">      queueForThread.offer(<span class="keyword">new</span> Event(event, subscribers));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dispatching.get()) &#123;</span><br><span class="line">        dispatching.set(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Event nextEvent;</span><br><span class="line">          <span class="keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;</span><br><span class="line">              nextEvent.subscribers.next().dispatchEvent(nextEvent.event);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          dispatching.remove();</span><br><span class="line">          queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSubscriber</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStatus</span><span class="params">(Integer status)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"subscriber  success + status : "</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusSubscriber</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStatus</span><span class="params">(String status)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"subscriber  success + status : "</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// guava的观察者机制相对于jdk来说使用起来更加简便，同时支持通知消息的分类及非阻塞方式的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> StatusSubscriber());</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> OtherSubscriber());</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="string">"ssss"</span>);</span><br><span class="line">        eventBus.post(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"end~~~~~~"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>spring框架实现</li>
</ol>
<p>spring自带实现最大的优势是所有的对象都可以交给spring去管理。大体功能和guava类似。</p>
<p>核心类：<strong>ApplicationEventPublisher</strong>（事件发布类）、<strong>ApplicationListener</strong>（事件监听器），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle an application event.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventNotify</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        executor = ThreadPoolExecutorFactory.of(<span class="string">"ApplicationEventSender"</span>,<span class="number">4</span>,<span class="number">10</span>,ThreadPoolExecutorFactory.CALLER_RUNER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event != <span class="keyword">null</span>)&#123;</span><br><span class="line">            executor.submit(() -&gt; applicationContext.publishEvent(event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        EventNotify.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventNotify.notifyListener(<span class="keyword">new</span> UserRoleChangeEvent(<span class="keyword">this</span>,userRoleForm.getUid()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRoleChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRoleChangeHandler userRoleChangeHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span>(classes = UserRoleChangeEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">receiveEvent</span>(<span class="title">final</span> <span class="title">UserRoleChangeEvent</span> <span class="title">event</span>)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"【UserRoleChange】event:&#123;&#125;"</span>, JSON.toJSONString(event));</span><br><span class="line">        userRoleChangeHandler.rolechange(event.getRoleId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
</search>
